/**
 * DAO class for {{&moduleName}}
 * {{&dao-desc}}
 * @module persistence/dao/{{&moduleName}}
 * @auto-gen
 *
 * Note: auto-gen code, NOT allowed to modify
 */
var Q                       = require('q');
var {{&modelName}}          = require('../model/{{&moduleName}}');
var logger                  = require('../../utils/logger').getLogger('persistence/dao/{{&moduleName}}');
{{#isCacheable}}
var util                    = require('util');
var Event                   = require('events');
{{/isCacheable}}

/**
 * DAO class to represent the CRUD operation on mongoose model '{{&modelName}}'
 *
 */
var {{&daoClassName}} = function() {

};

{{#isCacheable}}
util.inherits({{&daoClassName}}, Event.EventEmitter);

/**
 * Create a new {{&moduleName}} event
 */
{{&daoClassName}}.CREATE_EVENT = 'create';

/**
 * Update a {{&moduleName}} event
 */
{{&daoClassName}}.UPDATE_EVENT = 'update';

/**
 * Delete a {{&moduleName}} event
 */
{{&daoClassName}}.DELETE_EVENT = 'delete';

/**
 * Query a {{&moduleName}}
 */
{{&daoClassName}}.QUERY_EVENT = 'query';
{{/isCacheable}}

{{#createMethodGen}}
  {{> dao-create-method}}
{{/createMethodGen}}
  
{{#updateByKeyMethods}}
  {{> dao-entireUpdate-method}}
{{/updateByKeyMethods}}

{{#updateByCondition}}
  {{> dao-updateByCondition-method}}
{{/updateByCondition}}

{{#deleteByKeyMethods}}
  {{> dao-delByKey-method}}
{{/deleteByKeyMethods}}

{{#retrieveByKeyMethods}}
  {{> dao-retrieveByKey-method}}
{{/retrieveByKeyMethods}}

{{#retrieveByConditionMethodGen}}
  {{> dao-retrieveByCondition-method}}
{{/retrieveByConditionMethodGen}}

{{#countMethodGen}}
  {{> dao-count-method}}
{{/countMethodGen}}

var dao = new {{&daoClassName}}();
module.exports = exports = dao;

{{#isCacheable}}

// ========================================
//                  Cache
// ========================================

// default cache max size
var DEFAULT_CACHE_SIZE = {{&maxCacheSize}};

/**
 * The cache for user related query. This is a LRU cache, we only keep the specific number users in the cache
 * for the last recently accessed/queried
 * 
 */
var {{&daoClassName}}Cache = function(maxSize) {
  this.cacheSize = maxSize;
  if (! this.cacheSize) {
    this.cacheSize = DEFAULT_CACHE_SIZE;
  }
  this.records = [];

  dao.on({{&daoClassName}}.CREATE_EVENT, this.onCreate.bind(this));

  dao.on({{&daoClassName}}.UPDATE_EVENT, this.onUpdate.bind(this));
  
  dao.on({{&daoClassName}}.DELETE_EVENT, this.onDelete.bind(this));
  
  dao.on({{&daoClassName}}.QUERY_EVENT, this.onQuery.bind(this));
};

{{#retrieveByKeyMethods}}
  {{> dao-retrieveInCache-method}}
{{/retrieveByKeyMethods}}


/**
 * On create event listener, update the cache with new created record
 * @param {object} record
 *
 */
{{&daoClassName}}Cache.prototype._clone = function (source) {

  var self = this;

  if (! source) return null;

  if (typeof source === 'string' ||
    typeof source === 'number' ||
    typeof source === 'boolean') {
    
    return source;
  }
    

  if (Array.isArray(source)) {
    var cloned = [];
    for (i = 0; i < source.length; i++) {
      cloned[i] = self.clone(source[i]);
    }
  }

  if (typeof source === 'object') {
    var serialization = JSON.stringify(source);
    return JSON.parse(serialization);
  }

  throw new Error('Unsupported data type for clone operation: ' + typeof source);
};

/**
 * On create event listener, update the cache with new created record
 * @param {object} record
 *
 */
{{&daoClassName}}Cache.prototype.onCreate = function (record) {
  logger.debug('onCreate event is triggered: ', record);
  var self = this;

  if (! record || this.cacheSize === 0) return;

  if (self.records.length === self.cacheSize) {
    self.records.pop();
  }

  // make sure the object in cache is exactly same as what it is in db
  self.records.push(self._clone(record));
};

/**
 * On update event listener, update/append the cache with updated record
 * @param {object} record
 *
 */
{{&daoClassName}}Cache.prototype.onUpdate = function (record) {
  logger.debug('onUpdate event is triggered: ', record);
  var self = this;

  if (! record || this.cacheSize === 0) return;

  for (var i = self.records.length -1; i >=0; i--) {
    if (self.records[i]._id.toString() === record._id.toString()) {
      logger.debug('Update with uid - "' + record._id.toString() + '" in the cache');
      self.records.splice(i, 1);
    }
  }

  if (self.records.length === self.cacheSize) {
    self.records.pop();
  }

  // make sure the object in cache is exactly same as what it is in db
  self.records.push(self._clone(record));
};

/**
 * On delete event listener, delete the record from the cache, if it exists in cache
 * @param {object} record
 *
 */
{{&daoClassName}}Cache.prototype.onDelete = function (uid) {
  logger.debug('onDelete event is triggered: ', uid);

  if (! uid || this.cacheSize === 0) return;

  for (var i = this.records.length - 1; i >=0; i--) {
    if (this.records[i]._id.toString() === uid) {
      logger.debug('Remove record with uid - "' + uid + '" from cache');
      this.records.splice(i, 1);
    }
  }
};

/**
 * Adjust the cache items order according to the LRU
 * @param [object] _records
 *
 */
{{&daoClassName}}Cache.prototype.onQuery = function (_records) {
  logger.debug('onQuery event is triggered: ', _records);

  var self = this;
  if (! _records || this.cacheSize === 0) return;

  if (! Array.isArray(_records)) {
    _records = [_records];
  }

  _records.forEach(function(record) {
    for (var i = self.records.length - 1; i >=0; i--) {
      if (self.records[i]._id.toString() === record._id.toString()) {
        self.records.splice(i, 1);
      }
    }

    if (self.records.length === self.cacheSize) {
      self.records.pop();
    }

    self.records.push(self._clone(record));
  });

};

var cache = new {{&daoClassName}}Cache();
{{/isCacheable}}

