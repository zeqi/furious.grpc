
/**
 * Find records by query conditions, support both promise and callback invocation styles
 *
 * @function
 * @param {object} condition, expressed by JSON format
 * @param {object} opts, optional parameter, including the properties like "limit" and "skip"
 * @param {fn}, callback, optional parameter
 * @return {Promise} promise to perform a find action:
 * <li>record found: resolve with the found record
 * <li>record NOT found: resolve with undefine
 * <li>error occur during find: reject with the error
 *
 */
{{&daoClassName}}.prototype.retrieveByCondition = function (condition, opts, callback) {
  var method = 'retrieveByCondition';
  logger.debug(method, 'try to find record by ', condition);
  var self = this;
  
  if (opts && 'function' === typeof opts) {
    callback = opts;
    opts = null;
  }

  var skip = 0;
  if (opts && opts.skip) {
    skip = opts.skip;
  }
  var limit = undefined;
  if (opts && opts.limit) {
    limit = opts.limit;
    if (limit === 'unlimited') {
      limit = undefined;
    }
  }
  var sort = {};
  if (opts && opts.sort) {
    sort = opts.sort;
  }

  if (! condition) {
    condition = {};
  }
  return Q.Promise(function (resolve, reject) {
    {{&modelName}}().find(condition)
    .limit(limit)
    .skip(skip)
    .sort(sort)
    .lean()
    .exec(function (err, results) {
      if (err) {
        logger.error('error occur during find, will reject with the bellow error');
        logger.error(err);
        reject(err);
        return;
      }

      if (results) {
        logger.debug('record found, will resove with bellow record: ', results);
        resolve(results);
        return;
      }

      logger.debug('record NOT found, will resolve with undefine');
      resolve();
    });
  }).nodeify(callback);
};
