
/**
 * Remove a record by '{{&key}}', support both promise and callback invocation styles
 *
 * @function
 * @param {string}, key's value
 * @param {fn}, callback, optional
 * @return {Promise} promise to perform a update action:
 * <li>record found and updated: resolve with the removed record
 * <li>record NOT found: reject with null
 * <li>error occur during find and update: reject with the error causing failure
 *
 */
{{&daoClassName}}.prototype.deleteBy{{&methodSignature}} = function (key, callback) {
  var method = 'deleteBy{{&methodSignature}}';
  logger.debug(method, '>>>', key);
  var self = this;
  return Q.Promise(function (resolve, reject) {
    {{&modelName}}().findOneAndRemove({{=<% %>=}}{<%&key%>: key}<%={{ }}=%>, function (err, result) {
      if (err) {
        logger.error(method, '<<<', err);
        reject(err);
        return;
      }

      if (result) {
        logger.debug(method, '<<<', result);
        resolve(result);
        {{#isCacheable}}
        self.emit({{&daoClassName}}.DELETE_EVENT, result._id.toString());
        {{/isCacheable}}
        return;
      } 
      
      logger.debug(method, '<<<', 'Result is undefined');
      resolve();
    });
  }).nodeify(callback);
};
