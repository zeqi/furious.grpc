
/**
 * Update a record by '{{&key}}', support both promise and callback invocation styles
 *
 * @function
 * @param {string} key, the key to identity an record
 * @param {Object} record in json format
 * @param {fn}, callback, optional
 * @return {Promise} promise to perform a update action:
 * <li>record found and updated: resolve with the updated record
 * <li>record NOT found: reject with null
 * <li>error occur during find and update: reject with the error causing failure
 *
 */
{{&daoClassName}}.prototype.updateBy{{&methodSignature}} = function (key, update, callback) {

  var method = 'updateBy{{&methodSignature}}';
  logger.debug(method, '>>>', update);

  var self = this;
	var upsert = {{&upsert}}; 

  return Q.Promise(function (resolve, reject) {
    {{&modelName}}().findOneAndUpdate({{=<% %>=}}{<%&key%>: key}<%={{ }}=%>, update, {
      new: true,
			upsert: upsert
    }).lean().exec(function (err, result) {
      if (err) {
        logger.error(method, '<<<', err);
        reject(err);
        return;
      }

      if (result) {
        logger.debug(method, '<<<', result);
        resolve(result);
        {{#isCacheable}}
        self.emit({{&daoClassName}}.UPDATE_EVENT, result);
        {{/isCacheable}}
        return;
      }

      logger.debug(method, '<<<', 'Record not found');
      reject(new Error('user not found'));
    });
  }).nodeify(callback);
};
