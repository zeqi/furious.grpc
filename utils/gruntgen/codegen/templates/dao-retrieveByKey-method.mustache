
/**
 * Find a record by '{{&key}}', support both promise and callback invocation styles
 *
 * @function
 * @param {String} key's value
 * @param {fn}, callback, optional
 * @return {Promise} promise to perform a find action:
 * <li>record found: resolve with the found record
 * <li>record NOT found: resolve with undefine
 * <li>error occur during find: reject with the error
 *
 */
{{&daoClassName}}.prototype.retrieveBy{{&methodSignature}} = function (key, callback) {
  var method = 'retrieveBy{{&methodSignature}}';
  logger.debug(method, 'try to find record by ' + key);
  var self = this;
  
  {{#isCacheable}}
  return cache.retrieveBy{{&methodSignature}}(key).then(function(result) {
    if (result) {
      logger.debug('record found in cache, skip db retrieve');
      return result;
    }

    return Q.Promise(function (resolve, reject) {
      {{&modelName}}().findOne({{=<% %>=}}{<%&key%>: key}<%={{ }}=%>).lean().exec(function (err, result) {
        if (err) {
          logger.error('error occur during find, will reject with the bellow error');
          logger.error(err);
          reject(err);
          return;
        }

        if (result) {
          logger.debug('record found, will resove with bellow record: ', result);
          resolve(result);
          self.emit({{&daoClassName}}.QUERY_EVENT, result);
          return;
        }

        logger.debug('record NOT found, will resolve with undefine');
        resolve();
      });
    });
  }).nodeify(callback);
  {{/isCacheable}}
  {{^isCacheable}}
  return Q.Promise(function (resolve, reject) {
    {{&modelName}}().findOne({{=<% %>=}}{<%&key%>: key}<%={{ }}=%>).lean().exec(function (err, result) {
      if (err) {
        logger.error('error occur during find, will reject with the bellow error');
        logger.error(err);
        reject(err);
        return;
      }

      if (result) {
        logger.debug('record found, will resove with bellow record: ', result);
        resolve(result);
        return;
      }

      logger.debug('record NOT found, will resolve with undefine');
      resolve();
    });
  }).nodeify(callback);
  {{/isCacheable}}
};
