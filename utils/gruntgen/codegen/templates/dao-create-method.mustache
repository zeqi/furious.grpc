
/**
 * Create a record, support both promise and callback invocation styles
 *
 * @function
 * @param {Object} record in json format.
 * @param {fn}, callback, optional
 * @return {Promise} promise to create a record:
 * <li>succeed: resolve with the saved record
 * <li>failed: reject with the error caused failure
 *
 */
{{&daoClassName}}.prototype.createRecord = function (record, callback) {
  var self = this;
  logger.debug('Try to pesistent the bellow record(s): ', record);

  if (! record) return Q();
  var createInBatch = Array.isArray(record);

  var createPromises = [];
  if (! createInBatch) {
    record = [record];
  }

  record.forEach(function (_record) {
    createPromises.push(Q.Promise(function (resolve, reject) {
      var model = new {{&modelName}}()(_record);
      model.save(function (err, savedRecord) {
        if (err) {
          logger.error('Record create failed, will reject promise with the bellow error: ', err);
          reject(err);
        } else {
          logger.debug('bellow record created, will resolve promise with the created record: ', savedRecord);
          resolve(savedRecord.toObject());
          {{#isCacheable}}
          self.emit({{&daoClassName}}.CREATE_EVENT, savedRecord);
          {{/isCacheable}}
        }
      });
    }));
  });
  
  if (! createInBatch) {
    return createPromises[0].nodeify(callback);
  }

  return Q.allSettled(createPromises).then(function (results) {
    var createdRecords = [];
    results.forEach(function (result) {
        if (result.state === "fulfilled") {
            createdRecords.push(result.value);
        } else {
            logger.error('Error occurs during create record due to: ', result.reason);
        }
    });
    return createdRecords;
  }).nodeify(callback);

};
